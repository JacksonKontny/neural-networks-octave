function sgd (inputs, targets, nodeLayers, numEpochs, batchSize, eta=.1, tvt_split=[.6, .2, .2], stopping_accuracy=.98, cost_function='quadratic')    # New inputs:        # train_size: vector of three floats between 0 and 1 that designates the         # proportion of the data that will be used for training, validation, and testing        # respectively            # Initialize the weights and biases    weights = initialize_weights(nodeLayers, batchSize);    biases = initialize_biases(nodeLayers);        [train_data, validation_data, test_data] = get_train_validation_test_split(inputs, targets, tvt_split)        # loop through a total number of the epochs entered as input    for epoch = 1:numEpochs        # Get the correct x and y batches based on the input batch size        [x_batches, y_batches] = get_minibatches(inputs, targets, batchSize);        for idx = 1:length(x_batches)            # update the weights based on batched SGD            [weights, biases] = update_mini_batch(x_batches{idx}, y_batches{idx}, weights, biases, eta, nodeLayers, cost_function);        endfor        # Now that the batches for the epoch are complete, lets see how we're doing        [mse, correct] = evaluate(inputs, weights, biases, targets);        num_targets = length(targets);        percent = correct / num_targets;        printf('Epoch %i: MSE:\t%d, Correct: %i/%i, ACC: %f\n', epoch, mse, correct, num_targets, percent);        if stopping_accuracy >= percent:            break;        endif     endforendfunction